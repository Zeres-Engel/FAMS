"""
Attendance Log Generation Module for FAMS
Handles the automatic generation of attendance logs when schedules are created
"""
import datetime
import logging
import numpy as np
from bson.objectid import ObjectId

logger = logging.getLogger(__name__)

def generate_attendance_logs(db, schedules, semester_info=None):
    """
    Generate attendance logs for a set of schedules
    
    Args:
        db: MongoDB database connection
        schedules: List of schedule entries generated by the scheduling algorithm
        semester_info: Optional semester information
        
    Returns:
        dict: Summary of attendance logs generated
    """
    if not schedules:
        logger.warning("No schedules provided for attendance log generation")
        return {"generated": 0, "errors": ["No schedules provided"]}
    
    logger.info(f"Generating attendance logs for {len(schedules)} schedules")
    
    attendance_logs = []
    errors = []
    
    # Get the next attendance ID
    next_attendance_id = 1
    last_attendance = db.AttendanceLog.find_one(sort=[("attendanceId", -1)])
    if last_attendance and "attendanceId" in last_attendance:
        try:
            next_attendance_id = int(last_attendance["attendanceId"]) + 1
        except (ValueError, TypeError):
            logger.warning(f"Could not parse attendanceId: {last_attendance.get('attendanceId')}. Starting from 1.")
    
    logger.info(f"Starting attendance ID: {next_attendance_id}")
    
    semester_number = None
    if semester_info:
        semester_number = semester_info.get('semesterNumber')
    
    # Process each schedule entry
    for schedule in schedules:
        schedule_id = schedule.get("scheduleId")
        if not schedule_id:
            logger.error(f"Schedule missing scheduleId: {schedule}")
            errors.append(f"Schedule missing scheduleId: {schedule}")
            continue
        
        # Get required information from schedule
        class_id = schedule.get("classId")
        teacher_id = schedule.get("teacherId")
        subject_id = schedule.get("subjectId")
        classroom_id = schedule.get("classroomId")
        
        # Get class information
        class_info = db.Class.find_one({"classId": class_id})
        if not class_info:
            logger.warning(f"Class not found for classId: {class_id}")
            class_name = schedule.get("className", f"Class {class_id}")
        else:
            class_name = class_info.get("className", f"Class {class_id}")
        
        # Get teacher information
        teacher = db.Teacher.find_one({"teacherId": teacher_id})
        if not teacher:
            logger.warning(f"Teacher not found for teacherId: {teacher_id}")
            teacher_name = schedule.get("teacherName", f"Teacher {teacher_id}")
            teacher_user_id = None
        else:
            teacher_name = teacher.get("fullName", f"Teacher {teacher_id}")
            teacher_user_id = teacher.get("userId")
        
        # Get subject information
        subject = db.Subject.find_one({"subjectId": subject_id})
        if not subject:
            logger.warning(f"Subject not found for subjectId: {subject_id}")
            subject_name = schedule.get("subjectName", f"Subject {subject_id}")
        else:
            subject_name = subject.get("subjectName", f"Subject {subject_id}")
        
        # Get classroom information
        classroom = db.Classroom.find_one({"classroomId": classroom_id})
        if not classroom:
            logger.warning(f"Classroom not found for classroomId: {classroom_id}")
            classroom_name = schedule.get("roomName", f"Room {classroom_id}")
        else:
            classroom_name = classroom.get("classroomName", classroom.get("roomName", f"Room {classroom_id}"))
        
        # Determine semester number from schedule if not provided
        if not semester_number:
            semester_number = schedule.get("semesterNumber", 1)
        
        # Create attendance log for teacher if teacher_user_id exists
        if teacher_user_id:
            # Random status for teacher: 70% Present, 20% Late, 10% Absent
            status_random = np.random.random()
            if status_random < 0.7:
                teacher_status = "Present"
            elif status_random < 0.9:
                teacher_status = "Late"
            else:
                teacher_status = "Absent"
                
            teacher_attendance = {
                "attendanceId": next_attendance_id,
                "scheduleId": schedule_id,
                "userId": teacher_user_id,
                "checkIn": None,
                "note": "",
                "status": teacher_status,
                "semesterNumber": semester_number,
                "createdAt": datetime.datetime.now(),
                "updatedAt": datetime.datetime.now(),
                "isActive": True,
                "userRole": "teacher",
                "teacherId": teacher_id,
                "teacherName": teacher_name,
                "subjectId": subject_id,
                "subjectName": subject_name,
                "classId": class_id,
                "className": class_name,
                "classroomId": classroom_id,
                "classroomName": classroom_name
            }
            attendance_logs.append(teacher_attendance)
            next_attendance_id += 1
        
        # Get all students in this class
        students_in_class = list(db.Student.find({"classIds": class_id, "isActive": True}))
        
        if not students_in_class:
            logger.warning(f"No students found for class ID: {class_id}")
            continue
        
        logger.info(f"Creating attendance logs for class ID {class_id} with {len(students_in_class)} students")
        
        # Create attendance logs for students
        for student in students_in_class:
            user_id = student.get("userId")
            if not user_id:
                logger.warning(f"Student missing userId: {student}")
                continue
                
            # Random status for students: 60% Present, 25% Late, 15% Absent
            status_random = np.random.random()
            if status_random < 0.6:
                student_status = "Present"
            elif status_random < 0.85:
                student_status = "Late"
            else:
                student_status = "Absent"
                
            attendance_log = {
                "attendanceId": next_attendance_id,
                "scheduleId": schedule_id,
                "userId": user_id,
                "checkIn": None,
                "note": "",
                "status": student_status,
                "semesterNumber": semester_number,
                "createdAt": datetime.datetime.now(),
                "updatedAt": datetime.datetime.now(),
                "isActive": True,
                "userRole": "student",
                "teacherId": teacher_id,
                "teacherName": teacher_name,
                "subjectId": subject_id,
                "subjectName": subject_name,
                "classId": class_id,
                "className": class_name,
                "studentId": student.get("studentId"),
                "studentName": student.get("fullName", ""),
                "classroomId": classroom_id,
                "classroomName": classroom_name
            }
            attendance_logs.append(attendance_log)
            next_attendance_id += 1
            
            # Save in batches of 1000 to avoid memory issues
            if len(attendance_logs) >= 1000:
                try:
                    # Check if we need to update attendance IDs to avoid conflicts
                    latest_attendance = db.AttendanceLog.find_one(sort=[("attendanceId", -1)])
                    if latest_attendance and "attendanceId" in latest_attendance:
                        current_max_id = int(latest_attendance["attendanceId"])
                        # If IDs in DB are greater than our calculated IDs
                        if current_max_id >= next_attendance_id - len(attendance_logs):
                            logger.info(f"Updating batch attendance IDs to avoid conflicts. Current max: {current_max_id}")
                            for i, log in enumerate(attendance_logs):
                                log["attendanceId"] = current_max_id + i + 1
                            # Update next_attendance_id for next batch
                            next_attendance_id = current_max_id + len(attendance_logs) + 1
                    
                    db.AttendanceLog.insert_many(attendance_logs)
                    logger.info(f"Inserted batch of {len(attendance_logs)} attendance logs")
                    attendance_logs = []
                except Exception as e:
                    logger.error(f"Failed to insert attendance logs batch: {str(e)}")
                    errors.append(f"Batch insertion error: {str(e)}")
                    
                    # Try individual insertion
                    success_count = 0
                    for log in attendance_logs:
                        try:
                            db.AttendanceLog.insert_one(log)
                            success_count += 1
                        except Exception as log_err:
                            logger.error(f"Failed to insert attendance log {log.get('attendanceId')}: {str(log_err)}")
                    
                    logger.info(f"Successfully inserted {success_count}/{len(attendance_logs)} logs individually")
                    attendance_logs = []
    
    # Insert any remaining attendance logs
    if attendance_logs:
        try:
            # Check for ID conflicts
            latest_attendance = db.AttendanceLog.find_one(sort=[("attendanceId", -1)])
            if latest_attendance and "attendanceId" in latest_attendance:
                current_max_id = int(latest_attendance["attendanceId"])
                # Only update if DB IDs are larger than calculated IDs
                if current_max_id >= next_attendance_id - len(attendance_logs):
                    logger.info(f"Updating final attendance IDs to avoid conflicts. Current max: {current_max_id}")
                    for i, log in enumerate(attendance_logs):
                        log["attendanceId"] = current_max_id + i + 1
            
            db.AttendanceLog.insert_many(attendance_logs)
            logger.info(f"Inserted final batch of {len(attendance_logs)} attendance logs")
        except Exception as e:
            logger.error(f"Failed to insert final batch: {str(e)}")
            errors.append(f"Final batch insertion error: {str(e)}")
            
            # Try individual insertion
            success_count = 0
            for log in attendance_logs:
                try:
                    db.AttendanceLog.insert_one(log)
                    success_count += 1
                except Exception as log_err:
                    logger.error(f"Failed to insert attendance log {log.get('attendanceId')}: {str(log_err)}")
            
            logger.info(f"Successfully inserted {success_count}/{len(attendance_logs)} logs individually")
    
    # Create summary
    total_logs = db.AttendanceLog.count_documents({})
    result = {
        "generated": next_attendance_id - (last_attendance.get("attendanceId", 0) if last_attendance else 0) - 1,
        "errors": errors,
        "total_logs_in_system": total_logs
    }
    
    logger.info(f"Attendance log generation completed: {result['generated']} logs generated")
    return result 